<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Peg Solitaire - Agua y Fuego</title>
  <style>
    body {
      background-color: #02132b;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      font-family: "Poppins", sans-serif;
      color: white;
      user-select: none;
    }

    h1 {
      color: fuchsia;
      margin-bottom: 10px;
      text-shadow: 0 0 10px fuchsia;
    }

    #hud {
      display: flex;
      gap: 20px;
      align-items: center;
      margin-bottom: 15px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(7, 60px);
      grid-template-rows: repeat(7, 60px);
      gap: 8px;
      background-color: #001a33;
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 0 30px fuchsia;
      position: relative;
    }

    .cell {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #0a284d;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: 0.2s;
      position: relative;
    }

    .invalid {
      visibility: hidden;
    }

    .piece {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background-size: cover;
      cursor: grab;
      transition: transform 0.2s;
    }

    .piece[data-type="fire"] {
      box-shadow: 0 0 25px rgba(255, 80, 0, 0.9);
      animation: glowFire 1.5s infinite alternate;
    }

    .piece[data-type="water"] {
      box-shadow: 0 0 25px rgba(0, 120, 255, 0.9);
      animation: glowWater 1.5s infinite alternate;
    }

    @keyframes glowFire {
      from { box-shadow: 0 0 15px rgba(255, 100, 0, 0.7); }
      to { box-shadow: 0 0 35px rgba(255, 40, 0, 1); }
    }

    @keyframes glowWater {
      from { box-shadow: 0 0 15px rgba(0, 140, 255, 0.7); }
      to { box-shadow: 0 0 35px rgba(0, 60, 255, 1); }
    }

    button {
      background-color: fuchsia;
      color: white;
      border: none;
      padding: 8px 20px;
      font-size: 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: 0.3s;
    }

    button:hover {
      background-color: #ff4aff;
    }

    /* 💡 Flechas animadas de hints */
    .hint {
      position: absolute;
      width: 26px;
      height: 26px;
      background-image: url('https://cdn-icons-png.flaticon.com/512/32/32195.png');
      background-size: contain;
      background-repeat: no-repeat;
      animation: floatHint 1s infinite ease-in-out;
      pointer-events: none;
      opacity: 0.9;
      transform-origin: center center;
    }

    @keyframes floatHint {
      0%, 100% { transform: translateY(0); opacity: 0.8; }
      50% { transform: translateY(-6px); opacity: 1; }
    }

    .hint.fire {
      filter: drop-shadow(0 0 12px orange) brightness(1.5);
      animation: glowHintFire 1s infinite ease-in-out;
    }

    .hint.water {
      filter: drop-shadow(0 0 12px cyan) brightness(1.5);
      animation: glowHintWater 1.5s infinite ease-in-out;
    }

    @keyframes glowHintFire {
      0%, 100% { filter: drop-shadow(0 0 12px orangered); }
      50% { filter: drop-shadow(0 0 25px yellow); }
    }

    @keyframes glowHintWater {
      0%, 100% { filter: drop-shadow(0 0 12px cyan); }
      50% { filter: drop-shadow(0 0 25px deepskyblue); }
    }

    #message {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(2, 19, 43, 0.9);
      color: fuchsia;
      font-size: 2em;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease;
    }

    #message.visible {
      opacity: 1;
      pointer-events: all;
    }
  </style>
</head>
<body>
  <h1>Peg Solitaire - Agua y Fuego</h1>

  <div id="hud">
    <div id="timer">Tiempo: 60s</div>
    <div id="score">Puntaje: 0</div>
    <button id="pauseBtn">Pausar</button>
    <button id="resetBtn">Reiniciar</button>
  </div>

  <div id="board"></div>
  <div id="message"></div>

  <script>
    const boardEl = document.getElementById("board");
    const timerEl = document.getElementById("timer");
    const scoreEl = document.getElementById("score");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const messageBox = document.getElementById("message");

    const rows = 7;
    const cols = 7;
    const types = ["fire", "water"];
    const images = {
      fire: "img/img_juego_peg/pieza_fuego.png",
      water: "img/img_juego_peg/pieza_agua.png",
    };

    const pattern = [
      [0,0,1,1,1,0,0],
      [0,0,1,1,1,0,0],
      [1,1,1,1,1,1,1],
      [1,1,1,0,1,1,1],
      [1,1,1,1,1,1,1],
      [0,0,1,1,1,0,0],
      [0,0,1,1,1,0,0]
    ];

    let board = [];
    let score = 0;
    let timer = 60;
    let interval = null;
    let paused = false;
    let dragged = null;

    function initBoard() {
      board = [];
      boardEl.innerHTML = "";

      for (let r = 0; r < rows; r++) {
        const row = [];
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = r;
          cell.dataset.col = c;

          if (pattern[r][c] === 0) {
            cell.classList.add("invalid");
          } else if (!(r === 3 && c === 3)) {
            const piece = document.createElement("div");
            const type = types[Math.floor(Math.random() * types.length)];
            piece.classList.add("piece");
            piece.dataset.type = type;
            piece.style.backgroundImage = `url(${images[type]})`;
            piece.draggable = true;
            cell.appendChild(piece);
          }
          boardEl.appendChild(cell);
          row.push(cell);
        }
        board.push(row);
      }

      enableDrag();
    }

    function enableDrag() {
      // Añadimos listeners a cada pieza
      document.querySelectorAll(".piece").forEach(p => {
        p.addEventListener("dragstart", dragStart);
        p.addEventListener("dragend", dragEnd);
      });

      // Hacemos que las celdas acepten drop mediante event delegation en el tablero
      // (seguimos manteniendo listeners por celda por compatibilidad)
      document.querySelectorAll(".cell").forEach(c => {
        c.addEventListener("dragover", dragOver);
        c.addEventListener("drop", drop);
      });
    }

    function dragStart(e) {
      dragged = e.target;
      // Si la pieza está dentro de otra etiqueta, asegurarnos de referenciar la pieza
      if (!dragged.classList.contains("piece")) {
        dragged = dragged.closest(".piece");
      }
      const cell = dragged.parentElement;
      const r = +cell.dataset.row;
      const c = +cell.dataset.col;
      showHints(r, c, dragged.dataset.type);
      // Opcional: pequeña pausa para evitar flicker visual en algunos navegadores
      setTimeout(() => {
        if (dragged) dragged.style.visibility = "visible";
      }, 0);
    }

    function dragEnd() {
      // restaurar estado
      dragged = null;
      clearHints();
    }

    function dragOver(e) {
      e.preventDefault();
    }

    function drop(e) {
      e.preventDefault();
      // Usar closest para detectar la celda aunque sueltes sobre un hijo
      const targetCell = e.target.closest(".cell");
      if (!dragged || !targetCell) return;

      const fromR = +dragged.parentElement.dataset.row;
      const fromC = +dragged.parentElement.dataset.col;
      const toR = +targetCell.dataset.row;
      const toC = +targetCell.dataset.col;

      if (isValidMove(fromR, fromC, toR, toC)) {
        const midR = (fromR + toR) / 2;
        const midC = (fromC + toC) / 2;
        const midCell = board[midR][midC];
        // Quitar la pieza intermedia y mover la arrastrada
        midCell.innerHTML = "";
        targetCell.appendChild(dragged);
        score += 10;
        scoreEl.textContent = `Puntaje: ${score}`;
        checkVictory();
        checkBlocked();
      }
      clearHints();
    }

    // JavaScript - Reemplaza esta función
    function isValidMove(fromR, fromC, toR, toC) {
        const fromPiece = board[fromR][fromC].querySelector('.piece');
        
        // Si el 'dragged' ya está definido fuera, puedes usarlo directamente,
        // pero es más seguro obtenerlo de la celda de origen:
        if (!fromPiece) return false;

        const jumperType = fromPiece.dataset.type; // Tipo de la pieza que salta
        
        let midR, midC; // Coordenadas de la pieza a eliminar

        // 1. Verificar movimiento vertical
        if (Math.abs(fromR - toR) === 2 && fromC === toC) {
            midR = (fromR + toR) / 2;
            midC = fromC;
        } 
        // 2. Verificar movimiento horizontal
        else if (Math.abs(fromC - toC) === 2 && fromR === toR) {
            midR = fromR;
            midC = (fromC + toC) / 2;
        } 
        // 3. No es un salto de Peg Solitaire válido
        else {
            return false;
        }

        const midCell = board[midR][midC];
        const targetCell = board[toR][toC];

        // Condición 1: La celda de destino debe estar vacía
        if (targetCell.children.length !== 0) return false;
        
        // Condición 2: Debe haber una pieza en la celda intermedia
        const jumpedPiece = midCell.querySelector('.piece');
        if (!jumpedPiece) return false;

        // Condición 3: ¡Regla Agua/Fuego!
        const jumpedType = jumpedPiece.dataset.type; // Tipo de la pieza saltada

        // Lógica que permite saltar sobre cualquier tipo (Iguales, Fuego sobre Agua, Agua sobre Fuego)
        // Si el requisito fuera más estricto (e.g., solo Fuego sobre Agua y Agua sobre Fuego, no sobre sí mismos), la condición cambia.

        /* REGLA CLÁSICA DEL SOLITARIO (CUALQUIER PIEZA ELIMINA CUALQUIER PIEZA):
        return true; 
        */
        
        // REGLA AGUA Y FUEGO (TODOS PUEDEN ELIMINAR A TODOS en este ejemplo de Solitario):
        return true; 
        
        /* SI QUISIERAS REGLAS MÁS COMPLEJAS:
        // Ejemplo: Fuego solo elimina Agua, Agua solo elimina Fuego
        if (jumperType === 'fire' && jumpedType === 'water') {
            return true;
        }
        if (jumperType === 'water' && jumpedType === 'fire') {
            return true;
        }
        return false;
        */
    }

    // Función mejorada con flechas visibles y orientadas (posicionamiento relativo)
    function showHints(r, c, type) {
      clearHints();
      const moves = [
        { r: r - 2, c, midR: r - 1, midC: c },
        { r: r + 2, c, midR: r + 1, midC: c },
        { r, c: c - 2, midR: r, midC: c - 1 },
        { r, c: c + 2, midR: r, midC: c + 1 }
      ];

      const boardRect = boardEl.getBoundingClientRect();

      moves.forEach(m => {
        if (
          m.r >= 0 && m.c >= 0 &&
          m.r < rows && m.c < cols &&
          !board[m.r][m.c].classList.contains("invalid") &&
          board[m.r][m.c].children.length === 0 &&
          board[m.midR][m.midC].children.length > 0
        ) {
          const targetCell = board[m.r][m.c];
          const targetRect = targetCell.getBoundingClientRect();

          const hint = document.createElement("div");
          hint.classList.add("hint", type);

          // Calculamos posición relativa al tablero (top/left en px)
          const top = targetRect.top - boardRect.top + (targetCell.offsetHeight / 4);
          const left = targetRect.left - boardRect.left + (targetCell.offsetWidth / 4);

          hint.style.top = `${top}px`;
          hint.style.left = `${left}px`;

          // Orientación según dirección
          if (m.r < r) hint.style.transform = "rotate(-90deg)";
          if (m.r > r) hint.style.transform = "rotate(90deg)";
          if (m.c < c) hint.style.transform = "rotate(180deg)";
          if (m.c > c) hint.style.transform = "rotate(0deg)";

          boardEl.appendChild(hint);
        }
      });
    }

    function clearHints() {
      document.querySelectorAll(".hint").forEach(h => h.remove());
    }

    function checkVictory() {
      const piecesLeft = document.querySelectorAll(".piece").length;
      if (piecesLeft === 1) {
        clearInterval(interval);
        showMessage(`🏆 ¡Victoria!<br>Puntaje final: ${score}`);
      }
    }

    function checkBlocked() {
      const pieces = document.querySelectorAll(".piece");
      let hasMove = false;

      pieces.forEach(piece => {
        const cell = piece.parentElement;
        const r = +cell.dataset.row;
        const c = +cell.dataset.col;

        const moves = [
          { r: r - 2, c, midR: r - 1, midC: c },
          { r: r + 2, c, midR: r + 1, midC: c },
          { r, c: c - 2, midR: r, midC: c - 1 },
          { r, c: c + 2, midR: r, midC: c + 1 }
        ];

        for (const m of moves) {
          if (
            m.r >= 0 && m.c >= 0 &&
            m.r < rows && m.c < cols &&
            !board[m.r][m.c].classList.contains("invalid") &&
            board[m.r][m.c].children.length === 0 &&
            board[m.midR][m.midC].children.length > 0
          ) {
            hasMove = true;
            break;
          }
        }
      });

      if (!hasMove) {
        clearInterval(interval);
        showMessage(`🚫 Sin movimientos posibles<br>Puntaje final: ${score}`);
      }
    }

    function startTimer() {
      clearInterval(interval);
      interval = setInterval(() => {
        if (!paused) {
          timer--;
          timerEl.textContent = `Tiempo: ${timer}s`;
          if (timer <= 0) {
            clearInterval(interval);
            showMessage(`⏰ ¡Tiempo terminado!<br>Puntaje final: ${score}`);
          }
        }
      }, 1000);
    }

    function showMessage(text) {
      messageBox.innerHTML = `<div>${text}</div><button onclick="resetGame()">Jugar de nuevo</button>`;
      messageBox.classList.add("visible");
    }

    function resetGame() {
      messageBox.classList.remove("visible");
      clearInterval(interval);
      timer = 60;
      score = 0;
      paused = false;
      pauseBtn.textContent = "Pausar";
      timerEl.textContent = "Tiempo: 60s";
      scoreEl.textContent = "Puntaje: 0";
      initBoard();
      startTimer();
    }

    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Reanudar" : "Pausar";
    });

    resetBtn.addEventListener("click", resetGame);

    // Inicializa todo
    initBoard();
    startTimer();
  </script>
</body>
</html>
