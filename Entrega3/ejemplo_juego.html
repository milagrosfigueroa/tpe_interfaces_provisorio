<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rompecabezas giratorio con selección</title>
  <style src="style.css"></style>
</head>
<body>

  <div class="btn-container">
    <button data-pieces="4">4 piezas</button>
    <button data-pieces="6">6 piezas</button>
    <button data-pieces="8">8 piezas</button>
  </div>

  <div id="message"></div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const message = document.getElementById("message");
    const buttons = document.querySelectorAll('button[data-pieces]');

    let hasInteracted = false;
    let cols = 2;
    let rows = 2;
    let pieceWidth, pieceHeight;
    let rotations = [];
    let imagen = new Image();

    // Ruta imagen - ajusta si hace falta
    imagen.src = "alaska.jpg";

    // Cuando la imagen carga, iniciamos con 4 piezas (2x2)
    imagen.onload = () => {
      setPuzzle(4);
    };

    // Asignar eventos a botones
    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const totalPieces = parseInt(button.getAttribute('data-pieces'), 10);
        setPuzzle(totalPieces);
      });
    });

    function setPuzzle(totalPieces) {
      hasInteracted = false;
      message.textContent = "";

      // Definir filas y columnas según cantidad piezas
      switch (totalPieces) {
        case 4:
          cols = 2; rows = 2;
          break;
        case 6:
          cols = 3; rows = 2;
          break;
        case 8:
          cols = 4; rows = 2;
          break;
        default:
          cols = 2; rows = 2;
      }

      // Ajustar canvas manteniendo proporción imagen
      canvas.width = 500;
      canvas.height = (imagen.height / imagen.width) * canvas.width;

      pieceWidth = canvas.width / cols;
      pieceHeight = canvas.height / rows;

      // Crear matriz de rotaciones aleatorias
      rotations = [];
      for(let r = 0; r < rows; r++){
        rotations[r] = [];
        for(let c = 0; c < cols; c++){
          const angles = [0, 90, 180, 270];
          rotations[r][c] = angles[Math.floor(Math.random() * angles.length)];
        }
      }

      drawPuzzle();
    }

    function drawPuzzle() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const imgPieceWidth = imagen.width / cols;
      const imgPieceHeight = imagen.height / rows;

      // ¿Puzzle resuelto?
      let isSolved = true;
      for(let r = 0; r < rows; r++){
        for(let c = 0; c < cols; c++){
          if(rotations[r][c] !== 0){
            isSolved = false;
            break;
          }
        }
        if(!isSolved) break;
      }

      ctx.filter = isSolved ? 'none' : 'grayscale(100%)';

      for(let r = 0; r < rows; r++){
        for(let c = 0; c < cols; c++){
          const angle = rotations[r][c];
          const sx = c * imgPieceWidth;
          const sy = r * imgPieceHeight;
          const dx = c * pieceWidth;
          const dy = r * pieceHeight;

          ctx.save();
          ctx.translate(dx + pieceWidth / 2, dy + pieceHeight / 2);
          ctx.rotate(angle * Math.PI / 180);
          ctx.drawImage(imagen, sx, sy, imgPieceWidth, imgPieceHeight, -pieceWidth/2, -pieceHeight/2, pieceWidth, pieceHeight);
          ctx.restore();
        }
      }

      ctx.filter = 'none';

      // Dibujar líneas de división
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      for(let i = 1; i < cols; i++){
        const x = pieceWidth * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for(let i = 1; i < rows; i++){
        const y = pieceHeight * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      checkIfSolved();
    }

    canvas.addEventListener('mousedown', (e) => {
      hasInteracted = true;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor(x / pieceWidth);
      const row = Math.floor(y / pieceHeight);

      if(e.button === 0){
        rotations[row][col] = (rotations[row][col] + 90) % 360;
      } else if(e.button === 2){
        rotations[row][col] = (rotations[row][col] + 270) % 360;
      }

      drawPuzzle();
    });

    canvas.addEventListener('contextmenu', e => e.preventDefault());

    function checkIfSolved() {
      for(let r = 0; r < rows; r++){
        for(let c = 0; c < cols; c++){
          if(rotations[r][c] !== 0){
            message.textContent = "";
            return false;
          }
        }
      }
      if(hasInteracted){
        message.textContent = "¡Puzzle resuelto!";
      }
      return true;
    }
  </script>
</body>
</html>
